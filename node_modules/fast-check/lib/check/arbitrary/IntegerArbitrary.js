"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.maxSafeNat = exports.maxSafeInteger = exports.nat = exports.integer = void 0;
const ArbitraryWithShrink_1 = require("./definition/ArbitraryWithShrink");
const BiasedArbitraryWrapper_1 = require("./definition/BiasedArbitraryWrapper");
const Shrinkable_1 = require("./definition/Shrinkable");
const BiasNumeric_1 = require("./helpers/BiasNumeric");
const ShrinkNumeric_1 = require("./helpers/ShrinkNumeric");
class IntegerArbitrary extends ArbitraryWithShrink_1.ArbitraryWithShrink {
    constructor(min, max) {
        super();
        this.biasedIntegerArbitrary = null;
        this.min = min === undefined ? IntegerArbitrary.MIN_INT : min;
        this.max = max === undefined ? IntegerArbitrary.MAX_INT : max;
    }
    wrapper(value, shrunkOnce) {
        return new Shrinkable_1.Shrinkable(value, () => this.shrink(value, shrunkOnce).map((v) => this.wrapper(v, true)));
    }
    generate(mrng) {
        return this.wrapper(mrng.nextInt(this.min, this.max), false);
    }
    shrink(value, shrunkOnce) {
        return ShrinkNumeric_1.shrinkNumber(this.min, this.max, value, shrunkOnce === true);
    }
    pureBiasedArbitrary() {
        if (this.biasedIntegerArbitrary != null) {
            return this.biasedIntegerArbitrary;
        }
        const log2 = (v) => Math.floor(Math.log(v) / Math.log(2));
        this.biasedIntegerArbitrary = BiasNumeric_1.biasNumeric(this.min, this.max, IntegerArbitrary, log2);
        return this.biasedIntegerArbitrary;
    }
    withBias(freq) {
        return BiasedArbitraryWrapper_1.biasWrapper(freq, this, (originalArbitrary) => originalArbitrary.pureBiasedArbitrary());
    }
}
IntegerArbitrary.MIN_INT = 0x80000000 | 0;
IntegerArbitrary.MAX_INT = 0x7fffffff | 0;
function integer(a, b) {
    if (a !== undefined && b !== undefined && a > b)
        throw new Error('fc.integer maximum value should be equal or greater than the minimum one');
    return b === undefined ? new IntegerArbitrary(undefined, a) : new IntegerArbitrary(a, b);
}
exports.integer = integer;
function maxSafeInteger() {
    return integer(Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
}
exports.maxSafeInteger = maxSafeInteger;
function nat(a) {
    if (a !== undefined && a < 0)
        throw new Error('fc.nat value should be greater than or equal to 0');
    return new IntegerArbitrary(0, a);
}
exports.nat = nat;
function maxSafeNat() {
    return nat(Number.MAX_SAFE_INTEGER);
}
exports.maxSafeNat = maxSafeNat;
