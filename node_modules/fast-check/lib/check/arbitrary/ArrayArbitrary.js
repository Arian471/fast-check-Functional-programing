"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.array = exports.ArrayArbitrary = void 0;
const Stream_1 = require("../../stream/Stream");
const symbols_1 = require("../symbols");
const Arbitrary_1 = require("./definition/Arbitrary");
const BiasedArbitraryWrapper_1 = require("./definition/BiasedArbitraryWrapper");
const Shrinkable_1 = require("./definition/Shrinkable");
const IntegerArbitrary_1 = require("./IntegerArbitrary");
const LazyIterableIterator_1 = require("../../stream/LazyIterableIterator");
class ArrayArbitrary extends Arbitrary_1.Arbitrary {
    constructor(arb, minLength, maxLength, preFilter = (tab) => tab) {
        super();
        this.arb = arb;
        this.minLength = minLength;
        this.maxLength = maxLength;
        this.preFilter = preFilter;
        this.lengthArb = IntegerArbitrary_1.integer(minLength, maxLength);
    }
    static makeItCloneable(vs, shrinkables) {
        vs[symbols_1.cloneMethod] = () => {
            const cloned = [];
            for (let idx = 0; idx !== shrinkables.length; ++idx) {
                cloned.push(shrinkables[idx].value);
            }
            this.makeItCloneable(cloned, shrinkables);
            return cloned;
        };
        return vs;
    }
    wrapper(itemsRaw, shrunkOnce) {
        const items = this.preFilter(itemsRaw);
        let cloneable = false;
        const vs = [];
        for (let idx = 0; idx !== items.length; ++idx) {
            const s = items[idx];
            cloneable = cloneable || s.hasToBeCloned;
            vs.push(s.value);
        }
        if (cloneable) {
            ArrayArbitrary.makeItCloneable(vs, items);
        }
        return new Shrinkable_1.Shrinkable(vs, () => this.shrinkImpl(items, shrunkOnce).map((v) => this.wrapper(v, true)));
    }
    generate(mrng) {
        const size = this.lengthArb.generate(mrng);
        const items = [];
        for (let idx = 0; idx !== size.value; ++idx) {
            items.push(this.arb.generate(mrng));
        }
        return this.wrapper(items, false);
    }
    shrinkImpl(items, shrunkOnce) {
        if (items.length === 0) {
            return Stream_1.Stream.nil();
        }
        const size = this.lengthArb.shrinkableFor(items.length, shrunkOnce);
        return size
            .shrink()
            .map((l) => items.slice(items.length - l.value))
            .join(items[0].shrink().map((v) => [v].concat(items.slice(1))))
            .join(items.length > this.minLength
            ? LazyIterableIterator_1.makeLazy(() => this.shrinkImpl(items.slice(1), false)
                .filter((vs) => this.minLength <= vs.length + 1)
                .map((vs) => [items[0]].concat(vs)))
            : Stream_1.Stream.nil());
    }
    withBias(freq) {
        return BiasedArbitraryWrapper_1.biasWrapper(freq, this, (originalArbitrary) => {
            const lowBiased = new ArrayArbitrary(originalArbitrary.arb.withBias(freq), originalArbitrary.minLength, originalArbitrary.maxLength, originalArbitrary.preFilter);
            const highBiasedArbBuilder = () => {
                return originalArbitrary.minLength !== originalArbitrary.maxLength
                    ? new ArrayArbitrary(originalArbitrary.arb.withBias(freq), originalArbitrary.minLength, originalArbitrary.minLength +
                        Math.floor(Math.log(originalArbitrary.maxLength - originalArbitrary.minLength) / Math.log(2)), originalArbitrary.preFilter)
                    : new ArrayArbitrary(originalArbitrary.arb.withBias(freq), originalArbitrary.minLength, originalArbitrary.maxLength, originalArbitrary.preFilter);
            };
            return BiasedArbitraryWrapper_1.biasWrapper(freq, lowBiased, highBiasedArbBuilder);
        });
    }
}
exports.ArrayArbitrary = ArrayArbitrary;
function array(arb, aLength, bLength) {
    if (bLength == null)
        return new ArrayArbitrary(arb, 0, aLength == null ? 10 : aLength);
    return new ArrayArbitrary(arb, aLength || 0, bLength);
}
exports.array = array;
